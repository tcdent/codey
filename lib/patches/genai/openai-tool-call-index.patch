diff --git a/src/adapter/adapters/openai/streamer.rs b/src/adapter/adapters/openai/streamer.rs
--- a/src/adapter/adapters/openai/streamer.rs
+++ b/src/adapter/adapters/openai/streamer.rs
@@ -185,9 +185,18 @@ impl futures::Stream for OpenAIStreamer {
 										match &mut self.captured_data.tool_calls {
 											Some(calls) => {
 												self.captured_data.tool_calls = Some({
+													// Ensure vector is large enough for this index
+													let idx = index as usize;
+													while calls.len() <= idx {
+														calls.push(crate::chat::ToolCall {
+															call_id: String::new(),
+															fn_name: String::new(),
+															fn_arguments: serde_json::Value::String(String::new()),
+														});
+													}
 													// Accumulate arguments as strings, don't parse until complete
 													let accumulated = if let Some(existing) =
-														calls[index as usize].fn_arguments.as_str()
+														calls[idx].fn_arguments.as_str()
 													{
 														format!("{}{}", existing, arguments)
 													} else {
@@ -194,16 +204,16 @@ impl futures::Stream for OpenAIStreamer {
 													};
 
 													// Store as string (will be parsed at stream end)
-													calls[index as usize].fn_arguments =
+													calls[idx].fn_arguments =
 														serde_json::Value::String(accumulated);
 
 													// Update call_id and fn_name on first chunk
 													if !tool_call.fn_name.is_empty() {
-														calls[index as usize].call_id = tool_call.call_id.clone();
-														calls[index as usize].fn_name = tool_call.fn_name.clone();
+														calls[idx].call_id = tool_call.call_id.clone();
+														calls[idx].fn_name = tool_call.fn_name.clone();
 													}
 
-													tool_call = calls[index as usize].clone();
+													tool_call = calls[idx].clone();
 													calls.to_vec()
 												})
 											}
